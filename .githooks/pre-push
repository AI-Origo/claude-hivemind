#!/bin/bash
# pre-push hook - Auto-bump version based on conventional commits
#
# Analyzes commits being pushed and bumps version accordingly:
# - feat!: or BREAKING CHANGE: → major bump
# - feat: → minor bump
# - fix: → patch bump

set -euo pipefail

# Get the root of the repo
REPO_ROOT=$(git rev-parse --show-toplevel)
PLUGIN_JSON="$REPO_ROOT/.claude-plugin/plugin.json"

if [[ ! -f "$PLUGIN_JSON" ]]; then
  exit 0
fi

# Get current version
CURRENT_VERSION=$(jq -r '.version' "$PLUGIN_JSON")
if [[ -z "$CURRENT_VERSION" || "$CURRENT_VERSION" == "null" ]]; then
  exit 0
fi

# Parse version components
IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

# Find the last version tag, or use initial commit if none
LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
if [[ -n "$LAST_TAG" ]]; then
  COMMIT_RANGE="${LAST_TAG}..HEAD"
else
  # No tags yet, check all commits on current branch
  COMMIT_RANGE="HEAD"
fi

# Analyze commits for conventional commit types
COMMITS=$(git log "$COMMIT_RANGE" --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s")

BUMP_TYPE=""
while IFS= read -r msg; do
  # Skip empty lines and version bump commits
  [[ -z "$msg" ]] && continue
  [[ "$msg" =~ ^chore.*:.*bump\ version ]] && continue
  [[ "$msg" =~ ^chore\(release\) ]] && continue

  # Check for breaking changes (major bump)
  if [[ "$msg" =~ ^[a-z]+!: ]] || [[ "$msg" =~ BREAKING\ CHANGE ]]; then
    BUMP_TYPE="major"
    break
  fi

  # Check for features (minor bump)
  if [[ "$msg" =~ ^feat: ]] || [[ "$msg" =~ ^feat\( ]]; then
    if [[ "$BUMP_TYPE" != "major" ]]; then
      BUMP_TYPE="minor"
    fi
  fi

  # Check for fixes (patch bump)
  if [[ "$msg" =~ ^fix: ]] || [[ "$msg" =~ ^fix\( ]]; then
    if [[ -z "$BUMP_TYPE" ]]; then
      BUMP_TYPE="patch"
    fi
  fi
done <<< "$COMMITS"

# No version-worthy commits found
if [[ -z "$BUMP_TYPE" ]]; then
  exit 0
fi

# Calculate new version
case "$BUMP_TYPE" in
  major)
    NEW_VERSION="$((MAJOR + 1)).0.0"
    ;;
  minor)
    NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
    ;;
  patch)
    NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
    ;;
esac

# Check if version already matches (avoid duplicate bumps)
if [[ "$CURRENT_VERSION" == "$NEW_VERSION" ]]; then
  exit 0
fi

# Check if the most recent commit is already a version bump to this version
LAST_COMMIT_MSG=$(git log -1 --pretty=format:"%s")
if [[ "$LAST_COMMIT_MSG" == "chore: bump version to $NEW_VERSION" ]]; then
  exit 0
fi

echo "Bumping version: $CURRENT_VERSION → $NEW_VERSION ($BUMP_TYPE)"

# Update plugin.json
jq --arg v "$NEW_VERSION" '.version = $v' "$PLUGIN_JSON" > "$PLUGIN_JSON.tmp" \
  && mv "$PLUGIN_JSON.tmp" "$PLUGIN_JSON"

# Create version bump commit
git add "$PLUGIN_JSON"
git commit -m "chore: bump version to $NEW_VERSION"

echo "Created version bump commit. Push will continue with new commit."
